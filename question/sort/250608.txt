先回顾 250602优先列表.md 最后面的问题。

1. 对 选择排序、所有元素均相同的快速排序、
待排序数组已经有序且不扰乱的快速排序，
分析他们所需要的比较次数。

2. 一个按子降序排列的数组也是一个面向最大元素的堆吗？

3. 在堆中，最大的元素一定在位置1上，第二大的元素呢？第3大的元素呢？第4大呢？

4. 给出 A B C D E 五个元素可能构造出来的所有堆，然后
给出 A A A B B 之五个元素可能构造出来的所有堆。

5. 假设我们不想浪费堆有序的数组Data[]中的那个位置(位置0)，将最大的元素
放在Data[0]，它的子结点放在Data[1]和Data[2]，以此类推。Data[k]的父结
点和子结点在哪里？

6. 如果你的应用中有大量的 插入元素 的操作，但只有若干 删除最大元素 的操作，
哪种优先队列的实现方法更有效：堆、无序数组、有序数组？

7. 如果你的应用场景中大量的找出 最大元素 的操作，但 插入元素 和 删除最大元素
的操作相对较少，哪种优先队列的实现方式更有效：堆、无序数组、有序数组？

8. 想办法在sink()中避免检查 j < N .

9. 对于没有重复元素的大小为N的堆，一次删除最大元素的操作中最少要交换几个元素？
构造一个能够达到这个交换次数的大小为15的堆。连续两次删除最大元素呢？三次呢？

10. 设计一个程序，在线性时间内检测数组pq[]是否是一个面向最小元素的堆。

