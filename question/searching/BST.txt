1、维护 Node 对象中的结点计数器似乎需要很多代码，这有必要吗？为什么不只用
    一个变量来保存整棵树中的结点总数来实现用例中的size()方法？

2、将 E A S Y Q U E S T I O N 作为键按顺序插入一棵初始为空的二叉查找树中
    （方便起见设第i个键对应的值为i），画出生成的二叉查找树。构造这棵树需要多少次比较？

3、将 A X C S E R H 作为键按顺序插入将会构造出一棵最坏情况下的二叉查找树结构，最下方
    的结点的两个链接全部为空，其他结点都含有一个空链接。用这些键给出构造最坏情况下的树
    的其他排列。

4、给了 A X C S E R H 的几种能够构造出 最优二叉查找树 的排列。

5、假设某棵二叉查找树的所有键均为 1 至 10 的整数，而我们要查找 5。那么以下哪个不可能是
    键的检查序列？
   a. 10, 9, 8, 7, 6, 5
   b. 4, 10, 8, 7, 5, 3
   c. 1, 10, 2, 9, 3, 8, 4, 7, 6, 5
   d. 2, 7, 3, 8, 4, 5
   e. 1, 2, 10, 4, 8, 5

6、对于 N=2、3、4、5、6，画出用N个键可能构造出的所有不同形状的二叉查找树。

7、为二叉查找树实现非递归的 put() 和 get()方法

8、为二叉查找树实现非递归的 min()、max()、floor()、ceiling()、rank()、select()方法

9、实现一种二叉查找树，舍弃 rank() 和 select() 方法并且不在Node对象中使用计数器
